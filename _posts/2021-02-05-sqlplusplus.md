---
layout: default
title:  "Querying JSON data with SQL++"
date:   2021-02-05 16:21:38 -0800
categories: bdms, big data, sql++, nosql
excerpt: "SQL++ is an extended SQL language used to query JSON data. It’s used in Apache AstrixDB – a big data management system (BDMS) that stores and manages semi-structured data, a la a NoSQL style data model."
---

SQL++ is an extended SQL language used to query JSON data. It’s used in Apache AstrixDB – a big data management system (BDMS) that stores and manages semi-structured data, a la a NoSQL style data model.

One of the challenges that SQL practitioners experience using noSQL databases, such as MongoDB, is that these dbs use a query language that is syntactically different to SQL.  

SQL ++ bucks this trend, however, as it’s largely backward compatible with SQL. In fact, for the most part one can use traditional SQL to query AstrixDB. For example, let’s say that you want to pull up the record for employee with id = 100 from an employee table record set. 
A traditional SQL query can be run successfully in AstrixDB like this:
```sql
--sql
SELECT *
FROM employees
WHERE empID = 5  ;
```
**But!** Here’s the equivalent SQL++ query that will delivers the same result.

```sql
--sql++
FROM employees
WHERE empID = 5
SELECT * 
;
```
Those familiar with using C#’s LINQ queries will note similarity to the SQL++ structure.

Regardless of the compatibility between SQL and SQL++, however, there are naturally significant differences – SQL, after all, was created to work with structured data and relational DBs while SQL ++ was created to work with schema-less or flexible JSON datasets.
Below, we explore some notable differences with SQL++.


### 1.	Dataverses and Datasets instead of Databases and Tables

In a typical DBMS, data is stored in tables and organized within databases.  In contrast,  the SQL ++ equivalent is that data is put in datasets and which exist in a dataverse. In the below we demonstrate how to create a dataverse which contains 2 datasets and 2 datatypes. 


```sql ++
CREATE DATAVERSE Corporate IF NOT EXISTS;

USE Corporate;

CREATE TYPE emp_record  AS OPEN 
{
id:  int,
first_name:  string,
last_name: string,
startdate:  datetime
};

CREATE TYPE dep_record  AS CLOSED
{
id:  uuid,
dep_name: string,
manager_id: int,
created_date: datetime,
updated_date:  datetime?  
};

CREATE DATASET employees (emp_record) PRIMARY KEY id;

CREATE DATASET departments (dep_record) PRIMARY KEY id AUTOGENERATED;

```

*Datasets* are equivalent to tables, with the distinction that a dataset (specifically an internal dataset which is stored in Astrixdb) must be defined using a pre-declared *datatype*. For example, we created emp_record (a reusable object) which determined the schema for the dataset employees. 

Note also, that datasets must be created with a defined Primary Key. *(Although a field used for a primary key can be auto generated if the field is declared with the data type UUID.)*


### 2.	Flexible Schemas and Insertions

Notice that the type emp_record was declared as *OPEN* , as opposed to the type dep_record. An *open datatype* allows for a flexible schema – therefore, you 
can insert extra keys/fields into a dataset, beyond those declared.  

So, for example, the following is a completely acceptable and does not throw an error.


```sql
USE Corporate;

INSERT INTO employees (
{"id": 6, "first_name": "John" , 
"last_name": "Sheppard", "startdate": datetime("2008-01-31T13:00:00"),  
"rank": "Major", "books_read": float("0.5") }
);

```
The fields rank, and books_read weren’t defined *a priori* in the type emp_record; but, because emp_record is an open type we can insert new fields/keys without 
first declaring them. 

***But what if we don’t want willy-nilly key insertions?***

To control for inserted fields, then declare a datatype as *CLOSED* – which we exemplified with dep_record type. Consequently, we cannot insert extra fields into 
the departments dataset.

Additionally, individual fields can be made  *optional* with a question mark (?). So, if an insert does not contain that pre-defined field it will not throw an error.  
In dep_record, for example, the updated_date field is defined as optional with ?.   
Thus, when we do the below insert, it will not raise an error even though the second record tuple does not have a updated_date field.

```sql
USE Corporate;

INSERT INTO departments ( [
{"dep_name": "Sales" , "manager_id": 7, 
"created_date": datetime("2020-01-31T13:00:00"), "updated_date": datetime("2020-01-31T13:00:00")},

{"dep_name": "Defense" , "manager_id": 6 , 
"created_date": datetime("2020-01-31T13:00:00")} 
]);
-- recall that our id field is being autogenerated

``` 

*(Sidenote: Schema flexibility can have some unintended pitfalls.  
For example, if you misspell a field name in a query, you won’t get an error.  Instead, for select queries, an empty set will be returned for that misspelt field. 
For insertions (for open datasets),  that misspelt field will be inserted as new field.)*


### 3.	SELECT VALUE statements

Unlike SQL queries which return data in a tabular form (or a scalar value in the case of some subqueries), the SQL ++ default is to return data as a tuple-like objects 
wrapped in curly braces {} with key-value pairs. See below.

```sql
USE Corporate;

FROM employees 
SELECT * 
LIMIT 3 ;

Results:

{ "employees": { "id": 1, "first_name": "Sara", "last_name": "Pembroke", "startdate": "2020-01-31T13:00:00.000Z" } }
{ "employees": { "id": 2, "first_name": "Roy", "last_name": "Atkins", "startdate": "2020-01-31T13:00:00.000Z" } }
{ "employees": { "id": 3, "first_name": "Beth", "last_name": "Redson", "startdate": "2020-01-31T13:00:00.000Z" } }

```

The *SELECT VALUE* clause strips away the keys in the key-value pair and returns just the values wrapped in an array []. For example, 

```sql
FROM employees e
SELECT  VALUE [id, first_name, last_name, startdate]
;

Results:

[ 1, "Sara", "Pembroke", "2020-01-31T13:00:00.000Z" ]
[ 2, "Roy", "Atkins", "2020-01-31T13:00:00.000Z" ]
[ 3, "Beth", "Redson", "2020-01-31T13:00:00.000Z" ]

```

***Besides the cosmetic changes, how is this ultimately useful?***

Well consider, for example, the following SQL++ query, *where we want to grab the employee record for the manager of the HR department*. 

```sql
USE Corporate;

FROM employees e
WHERE id = (FROM departments 
            WHERE dep_name = "HR" 
            SELECT manager_id)
SELECT e.*

Results:

Duration of all jobs: 0.141 sec
Success: Query Complete

```
Even though there exists a record for an HR manager in both datasets, the above query returned an empty tumple.  

*But Why?*

Well, the sub-select actually returned a tuple with a manager id, like so  -> { "manager_id": 3 } . This object cannot be compared against the scalar value (1 or 2 or 3…) of the id field. 

*Solution?* 

We solve this incompatibility with a SELECT VALUE statement like so:

```sql
USE Corporate;

FROM employees e
WHERE id = (FROM departments 
                       WHERE dep_name = "HR" 
                       SELECT VALUE manager_id)[0]
SELECT e.*

Results:
{"id": 3, "first_name": "Beth", "last_name": "Redson", "startdate": "2020-01-31T13:00:00.000Z" }
Duration of all jobs: 0.134 sec
Success: Query Complete

```
Now, with a SELECT VALUE clause the sub-select returns the data in an array, like so -> [3] . Then, using *array indexing*, we to pull the scalar value from the returned array.

There are limitations to SELECT VALUE statements, however. For example,  A select value statement can have only 1 expression. Consequently, 
the expression SELECT VALUE foo, fee, fum is not allowed. However, SELECT VALUE [foo, fee, fum] is allowed. 


### 4.	Multi-dimensionality & Non-atomic Fields

Relational schemas don’t support non-atomic fields, but a semi-structured data model does. So, the following schema set-up is perfectly acceptable.

```sql++
USE Corporate;

CREATE TYPE address_record  AS {
street_address:  string,
postal_code:   string,
town:  string?,
province:   string?
};

CREATE TYPE facility_record AS {
id:  uuid ,
name:  string,
address:  [ address_record ],
floors:   {{ int }}
};

CREATE DATASET facilities (facility_record) PRIMARY KEY id AUTOGENERATED;

```
Above, we first define an address_record type (it defaults to an open type). Subsequently, we define a facility_record type that uses 2 multi-dimensional fields/keys ‘address’ 
and ‘floors’. The address key stores an array type that contains address_record types. Floors will contain a *multiset* of integers.  

For SQL practitioners (possibly outside of Oracle collections), multidimensionality can be strange to work with. So, let’s see what insert into the Facilities dataset would like with multi-dimensional fields.

```sql++
Use Corporate;

INSERT INTO facilities ([
{"name": "Acre Building", 
"address" :  [ { "active": true ,"street_address": "101 Main Street" , "postal_code": "ZZZ-341" , "town": "Acre Town" , "province": "TC" } ],
 "floors":  {{ 1,2,3}}   
} 
]);

```
**But**, an array can contain multiple values! *So what does that multivalued array insert look like?*

```sql++
USE Corporate;

INSERT INTO facilities ([
{"name": "Ten Building" , 
"address":  [ 
{ "active":  true, "street_address": "75 Main Street" , "postal_code": "ZZZ-341" , "town": "Acre Town" , "province": "TC" },    
{ "active":  false , "street_address": "5 Ellis Street" , "postal_code": "ZZZ-341" , "town":  " Todd-Town" , "province": "RE" }  
], 
"floors":   {{ 4, 2,1 }}  }
]);

```
Now let's read the data inserted.  When we run a SELECT all on the facilities table, here’s the returned result.

```sql

Results:
{
    facilities: {
        id: "8acebd24-5828-a13a-bb73-7d81a42b2aaa",
        name: "Acre Building",
        address: [
            {
                active: true,
                street_address: "101 Main Street",
                postal_code: "ZZZ-341",
                town: "Acre Town",
                province: "TC"
            }
        ],
        floors: [
            1,
            2,
            3
        ]
    }

}
{
    facilities: {
        id: "8acebd24-8a28-a13a-bc18-f9ecf9ca18eb",
        name: "Saw Building",
        address: [
            {
                active: true,
                street_address: "500 Main Street",
                postal_code: "ZZZ-341",
                town: "Acre Town",
                province: "TC"
            }
        ],
        floors: [
            9,
            1,
            4
        ]
    }

}
{
    facilities: {
        id: "b03d9d4e-6403-0320-cb0b-fefac00c9f12",
        name: "Ten Building",
        address: [
            {
                active: true,
                street_address: "75 Main Street",
                postal_code: "ZZZ-341",
                town: "Acre Town",
                province: "TC"
            },
            {
                active: false,
                street_address: "5 Ellis Street",
                postal_code: "ZZZ-341",
                town: " Todd-Town",
                province: "RE"
            }
        ],
        floors: [
            4,
            2,
            1
        ]
    }

}

``` 


## Conclusion
SQL++ effectively bridges the gap between traditional SQL and NoSQL data models. As an extension on SQL,  traditional SQL practitioners an quickly onboard SQL ++ and a
pply their skills to querying JSON data.  

For more on SQL ++ , check out the [documentation]( https://asterixdb.apache.org/docs/0.9.6/sqlpp/manual.html) available from AstrixDB. 

